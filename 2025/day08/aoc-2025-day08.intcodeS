jt part1_limit:1000 &start
hlt
@raw raw_output: 0	 use_dle: 1  debug_box_info: 0  debug_pairs: 0 debug_pairs_heap: 0 print_stats: 1 
start: rbo &boxes
# weird compiler quirk: it accepts "rbo heap_size:1" but not "rbo heap_size: 1". odd.
rbo heap_size:0
# box --- pairs --- circptr --- circuits
# ^ &box[0]

# suppress compiler errors
@reference assertion_failed
@reference print_stats

####################################################
#
# AOC 2025 Day 8 Intcode Solver
#
# Input is in ASCII (UTF-32/UCS-4), output is in ASCII (UTF-32/UCS-4).
#
# Man, this might be my most ambitious attempt ever.
#
# Features:
#
# - Solves both parts
# - No built-in limits on input size -- whatever your IntcodeVM can handle
#
# All CRs ('\r' aka 13 or 0x0D) in input are **completely ignored**.
#
# Since the input size is indeterminate, EOF must be reported via any of these means:
#
# - A blank line
# - 0x00 (ASCII NUL)
# - 0x1A (Ctrl-Z, ASCII SB; MS-DOS or CPM end-of-file indicator)
# - 0x04 (Ctrl-D, ASCII EOT; Default EOF replacement character on *nix-style TTY drivers)
# - a negative number (`EOF` constant returned by `fgetc`, `getc`, or `getchar`; see `stdio.h`)

##########################
#
# EXECUTION OPTIONS BLOCK - Memory addresses 1, 4-5
#
# [1]: part1_limit: Default 1000.  Number of connections to attempt for part 1.
#                                  Running the example requires changing this to 10.
#
# [4]: raw_output: Default 0. 0 = ASCII output for integers. 1 = Output all integers as raw integer values.
# [5]: use_dle:    Default 1. 1 = Prefix all raw integer outputs with a a DLE (0x10) character.
#                             This flag will normally have no effect unless RawOutput is enabled.
# [5]: debug_box_info: If 1, output the coordinates of each box after reading the input
# [6]: debug_pairs:      If 1, print each pair of boxes before heapify (not very interesting)
# [7]: debug_pairs_heap: If 1, print each pair of boxes after heapify
# [8]: print_stats. Default 1. Print some statistics on the circuit calculations at the end
#      (not implemented)

#############################################################################
#
# PHASE 1: Read puzzle input
#
# Read each box

read_next_box:

# skip past the heap
# read one of the following: (a) an integer (X) followed by ','  -or- (b) immediate '\n' or EOF
@cpy ',' ~1
@cpy 0 ~2
@cpy 1 ~3
@cpy 1 ~4
@call &read_nonnegative_integer_checked
# ~2 = 1 if we read an integer terminated by '-', 0 if it was a blank line terminated by '\n'
jf ~2 &input_eof
@cpy ~1 box_x

# read an integer (Y) followed by ','. anything else will error.
@cpy ',' ~1
@cpy 0 ~2
@cpy 0 ~3
@cpy 0 ~4
@call &read_nonnegative_integer_checked
@cpy ~1 box_y

# read an integer (Z) followed by '\n'. anything else will error.
@cpy '\n' ~1
@cpy 0 ~2
@cpy 0 ~3
@cpy 0 ~4
@call &read_nonnegative_integer_checked
@cpy ~1 box_z

# [x, y, z, circuit_ptr]
@cpy box_x ~0
@cpy box_y ~1
@cpy box_z ~2
@cpy    -1 ~3
rbo 4

add box_count 1 box_count
@jmp &read_next_box

################################################################################################

input_eof:
@jlt box_count 2 &too_few_boxes

@callt debug_box_info &print_box_info

@cpy box_count unconnected_box_count

mul box_count 4  box_table_size
mul box_table_size -1 box_table_size_inv
@cpy box_table_size heap_size
@cpy box_table_size_inv heap_size_inv
add &boxes box_table_size pair_table_address


###############################################################################################
#
#
# PHASE 2: Build pair table

rbo box_table_size_inv

@reference build_pairs
@fn naked build_pairs() global(box_count, box_table_size, box_table_size_inv, heap_size, heap_size_inv, pair_count, pair_table_size, pair_table_size_inv, assertion_failed, assertion_failed_line, box_count_odd)

# there are no pairs if box_count < 2
@jlt box_count 2 &auto__return

# if we have n boxes, we first add (n-1) pairs, then n pairs, then (n-2) pairs...

@cpy 0 box1_id
@cpy box_table_size box1_to_pair_table
mul box_table_size -1 pair_table_to_next_box1
mul box1_count_odd:0 0 box1_count_odd
#add pair_table_to_box1:0 4 pair_table_to_next_box1

add box_count -1 max_box1

### OUTER LOOP: 0 < box1_id < box_count - 1
next_box1:
# read box 1's coordinates
mul ~0 -1 box1_x
mul ~1 -1 box1_y
mul ~2 -1 box1_z
rbo 4

# set up our RBO offsets (this is a HUGE pain in the ass)

# at this point:
# "rbo box1_to_pair_table" will set the relative base to the address of the pair table 
# We don't actually use this with the RBO opcode, however. it's simply used to keep track of a value we need to initialize box2_to_pair_table correctly.
# "rbo box2_to_pair_table" will set the relative base to the address of the pair table
# if we are at the pair table:
# "rbo pair_table_to_next_box1" will set the relative base so that ~0 is the NEXT box1
# "rbo pair_table_to_next_box2" will set the relative base so that ~0 is the NEXT box2
add box1_to_pair_table -4 box1_to_pair_table
@cpy box1_to_pair_table:0 box2_to_pair_table
add pair_table_to_next_box1 4 pair_table_to_next_box1
add pair_table_to_next_box1 4 pair_table_to_next_box2


add box1_id 1 box2_id
next_box2:
add box1_x:0 ~0 dist_vector
mul dist_vector dist_vector dist_vector
@cpy dist_vector:0          dist_total
add box1_y:0 ~1 dist_vector
mul dist_vector dist_vector dist_vector
add dist_total  dist_vector dist_total
add box1_z:0 ~2 dist_vector
mul dist_vector dist_vector dist_vector
add dist_total  dist_vector dist_total

rbo box2_to_pair_table:0
rbo pair_table_size
@cpy box1_id:0 ~0
@cpy box2_id:0 ~1
@cpy dist_total:0 ~2
rbo pair_table_size_inv

add pair_count 1 pair_count
add pair_table_size 3 pair_table_size
add pair_table_size_inv -3 pair_table_size_inv

advance_box2:
@reference advance_box2
# advance "box2"

add box2_id 1 box2_id
@jge box2_id box_count &last_box2

rbo pair_table_to_next_box2:0
# pair_table_to_next_box2 should not be zero at this point
jf pair_table_to_next_box2 &failed_assertion_1

add box2_to_pair_table -4 box2_to_pair_table
add pair_table_to_next_box2 4 pair_table_to_next_box2
@jmp &next_box2

last_box2:

###### 
# next box1

# pair_table_to_next_box2 should be zero at this point. alas.
jt pair_table_to_next_box2 &failed_assertion_2

# move box1 forward 1
add box1_id 1 box1_id
@jge box1_id max_box1:0 &last_box1

rbo pair_table_to_next_box1:0
@jmp &next_box1

last_box1:
# leave ourselves on the pairs table
rbo box_table_size_inv
@jmp &auto__return

failed_assertion_1:
@cpy __LINE__ assertion_failed_line
# pair_table_to_next_box2 was unexpectedly zero
@jmp &assertion_failed

failed_assertion_2:
@cpy __LINE__ assertion_failed_line
# pair_table_to_next_box2 was unexpectedly nonzero
@jmp &assertion_failed
@endfn

####################################################################################################
#
#
# PHASE 3: heapify the pairs table

done_build_pairs:
@reference done_build_pairs

# update the heap size

# add in the pairs table
add heap_size pair_table_size heap_size
# reserve space for circuit pointers (1 word per circuit, max 1 circuit per box)
add heap_size box_count heap_size
# and space for the circuit objects  (2 words per circuit, max 1 circuit per box)
add heap_size box_count heap_size
add heap_size box_count heap_size
# finally, set heap_size_inv correctly
mul heap_size -1 heap_size_inv

# if requested, print out all pairs
rbo heap_size
@callt debug_pairs &print_pairs
rbo heap_size_inv

rbo box_table_size

#############################################################################
#
# heapify_pairs()
#
# Convert the pairs table into a heap

@reference heapify_pairs
@fn naked heapify_pairs() global(boxes, pair_count, pair_table_size)

# https://en.wikipedia.org/wiki/Heapsort
# thanks to @atom on the Discord

# if pair_count is 0, some idjit fed us an input with only two electrical boxes
jf pair_count &auto__return

@cpy 0 start
@cpy 0 count2
scan_midpoint:
add start 1 start 
add count2:0 2 count2
@jlt count2 pair_count &scan_midpoint

mul start 3 start

loop:
jf start &auto__return
add start:0 -3 start

@cpy start root

siftDown:

# in the docs:
#    iLeftChild(i) = 2i + 1
#    iRightCHild(i) = 2i + 2
# we need to add 3 and 6 here cuz we're doing raw memory addresses and each element is 3 words
mul root 2 iLeftChild
add iLeftChild 3 iLeftChild
@jge iLeftChild:0 pair_table_size &loop

add iLeftChild 0 child

add iLeftChild 3 iRightChild
@jge iRightChild:0 pair_table_size &no_right_child
mul iLeftChild -1 iLeftChildInv
rbo iLeftChild
# I want a min-heap, so I need to check if the right child is greater than the right child
lt ~5 ~2 is_less
mul is_less 3 is_less
add is_less:0 child child
rbo iLeftChildInv:0
no_right_child:

add root:0 2 root_read
add child:0 2 child_read
# wikipedia article is checking a[root]<a[child]
# so we're checking for a[child]<a[root]
lt child_read:~0 root_read:~0 is_less
jf is_less &loop

# swap the two elements
mul root -1 root_inv
mul child -1 child_inv
rbo root
@cpy ~0 tmpa0
@cpy ~1 tmpa1
@cpy ~2 tmpa2
rbo root_inv:0
rbo child
@cpy ~0 tmpb0
@cpy ~1 tmpb1
@cpy ~2 tmpb2
@cpy tmpa0:0 ~0
@cpy tmpa1:0 ~1
@cpy tmpa2:0 ~2
rbo child_inv:0
rbo root
@cpy tmpb0:0 ~0
@cpy tmpb1:0 ~1
@cpy tmpb2:0 ~2
rbo root_inv

@cpy child root
@jmp &siftDown

@endfn

#############################################################################


debug_heapify_pairs_done:
@reference debug_heapify_pairs_done

rbo heap_size
@callt debug_pairs_heap &print_pairs
rbo heap_size_inv


add pair_table_address pair_table_size circuit_pointers_address
add circuit_pointers_address box_count circuits_address

add box_table_size pair_table_size boxes_to_circuit_pointers
mul boxes_to_circuit_pointers -1 boxes_to_circuit_pointers_inv

add boxes_to_circuit_pointers box_count boxes_to_circuits
mul boxes_to_circuits -1 boxes_to_circuits_inv

# at this point:
# 1. the pairs array is now the pairs heap, a min-heap
# 2. rb (the relative base) is pointed at root element of the pairs heap

#############################################################################
#
# CONNECTION BUILD LOOP
#
# build connections until unconnected_box_count and disjoint_circuit_count are both 0

process_next_pair:
#      box --- pairs --- circptr --- circuits --- heap_end
# rb =        ^ &pairs[0]

add stat_pairs_processed 1 stat_pairs_processed
@cpy ~0 box1
@cpy ~1 box2
# pairs always have box1 < box2
@cpy __LINE__ assertion_failed_line
jf box2 &assertion_failed
rbo box_table_size_inv

#      box --- pairs --- circptr --- circuits --- heap_end
# rb = ^ &box[0]

mul box1 4 box1_3_read_offset
add box1_3_read_offset 3 box1_3_read_offset
mul box2 4 box2_3_read_offset
add box2_3_read_offset 3 box2_3_read_offset

@cpy box1_3_read_offset:~0 box1_ptr
@cpy box2_3_read_offset:~0 box2_ptr

# which boxes are connected? box1, box2, both, neither?
rbo heap_size
#      box --- pairs --- circptr --- circuits --- heap_end
# rb =                                            ^ &heap_end


@jlt box1_ptr:0 0 &resolve_no_box1
@cpy box1_ptr ~1
@call &resolve_circuit_pointer
@cpy ~1 box1_circuit
resolve_no_box1:
@jlt box2_ptr:0 0 &resolve_no_box2
@cpy box2_ptr ~1
@call &resolve_circuit_pointer
@cpy ~1 box2_circuit
resolve_no_box2:
rbo heap_size_inv

#      box --- pairs --- circptr --- circuits --- heap_end
# rb = ^ &box[0]


# if box1_ptr<0 then it's either box2 or neither
@jlt box1_ptr 0 &box1_not_connected
# if box1_ptr>=0 and box2_ptr<0 then it's box1 only
@jlt box2_ptr 0 &box1_only

@reference debug_both_connected
debug_both_connected:

# okay, it's *both*.
# first check if both boxes are connected to the same circuit.
# if they are, there is nothing to be done here.
eq box1_circuit:0 box2_circuit:0 same_circuit
eq same_circuit:0 0 different_circuit
jt same_circuit &no_merge_required

# okay, we need to merge the two circuits
mul box1_circuit -1 box1_circuit_inv
mul box2_circuit -1 box2_circuit_inv
rbo boxes_to_circuits
rbo box2_circuit
# read circuit 2's count
@cpy ~0 circuit2_count
# change circuit 2's count to 0, marking it as merged
@cpy 0 ~0
# set the merge destination for circuit 2
@cpy box1_circuit ~1
rbo box2_circuit_inv:0
rbo box1_circuit
# add circuit 2's circuits to circuit 1
add ~0 circuit2_count:0 ~0
rbo box1_circuit_inv:0
rbo boxes_to_circuits_inv
# aaand we're done!
# there is 1 fewer circuit left
add disjoint_circuit_count -1 disjoint_circuit_count

no_merge_required:
add stat_circuits_merged different_circuit:0 stat_circuits_merged
add stat_pairs_redundant same_circuit stat_pairs_redundant
# if disjoint_circuit_count is not 0 (and it usually isn't), we aren't done. skip the check
jt disjoint_circuit_count &pair_finished_not_done
# disjoint_circuit_count just hit 0; we need to also check unconnected_box_count.
@jmp &pair_finished_circuit_merge

# box1 but not box2. add box2 to box1 circuit
box1_only:
@cpy __LINE__ assertion_failed_line
@jlt box1_circuit 0 &assertion_failed
add stat_pairs_adjoin 1 stat_pairs_adjoin

# point box2 at box1's circuit
@cpy box2_3_read_offset b1o_box2_write_ptr
@cpy box1_ptr b1o_box2_write_ptr:~0

# increment the circuit's count by 1
add boxes_to_circuits box1_circuit b1o_circuit_count_read
@cpy b1o_circuit_count_read b1o_circuit_count_write
# this is hideous
add b1o_circuit_count_read:~0 1 b1o_circuit_count_write:~0

# box2 is no longer disconnected from the rest of the grid
add unconnected_box_count -1 unconnected_box_count
@jmp &pair_finished

box1_not_connected:
@jlt box2_ptr 0 &neither_box_connected

@reference debug_box2_only
debug_box2_only:
# okay, box2 but not box1. add box1 to box2 circuit
add stat_pairs_adjoin 1 stat_pairs_adjoin

@cpy __LINE__ assertion_failed_line
@jlt box1_circuit 0 &assertion_failed

# point box2 at box1's circuit
@cpy box1_3_read_offset b2o_box1_write_ptr
@cpy box2_ptr b2o_box1_write_ptr:~0

# increment the circuit's count by 1
add boxes_to_circuits box2_circuit b2o_circuit_count_read
@cpy b2o_circuit_count_read b2o_circuit_count_write
# still hideous
add b2o_circuit_count_read:~0 1 b2o_circuit_count_write:~0

# box1 is no longer disconnected from the rest of the grid
add unconnected_box_count -1 unconnected_box_count
@jmp &pair_finished

neither_box_connected:

add stat_pairs_new 1 stat_pairs_new
# there is now 1 additional circuit that is not connected to anything else
add disjoint_circuit_count 1 disjoint_circuit_count 

# okay, this might actually be the most annoying one, cuz we now need to allocate a circuit and a circuit pointer
mul circuit_count 2 new_circuit_address
mul new_circuit_address -1 new_circuit_address_inv
@cpy circuit_pointers_count new_circuit_pointer_address

# allocate circuit pointer
rbo boxes_to_circuit_pointers
rbo circuit_pointers_count
# fortunately, we know where the new circuit will be allocated ahead of time, which simplifies matters
@cpy new_circuit_address ~0
rbo circuit_pointers_count_inv
# increment the number of circuit pointers
add circuit_pointers_count 1 circuit_pointers_count
mul circuit_pointers_count -1 circuit_pointers_count_inv

# now allocate a circuit

# rb = &circuit_pointers[0] so we need to move forward box_count
rbo box_count
rbo new_circuit_address:0 
# this circuit has two boxes
@cpy 2 ~0
# and is not merged
@cpy -1 ~1
rbo new_circuit_address_inv:0
# one more circuit
add circuit_count 1 circuit_count
# after a while the word "circuit" starts looking like it's spelled wrong. @.@

rbo boxes_to_circuits_inv
# now point the boxes at those circuits
@cpy box1_3_read_offset new_circuit_box1_write_offset
@cpy box2_3_read_offset new_circuit_box2_write_offset

@cpy new_circuit_pointer_address:0 new_circuit_box1_write_offset:~0 
@cpy new_circuit_pointer_address   new_circuit_box2_write_offset:~0

add unconnected_box_count -2 unconnected_box_count

pair_finished:
# if disjoint_circuit_count != 0, we aren't done
jt disjoint_circuit_count &pair_finished_not_done
pair_finished_circuit_merge:
# if unconnected_box_count != 0, we aren't done
jt unconnected_box_count &pair_finished_not_done

# unconnected_box_count == 0.
mul box1 4 box1_x_read
mul box2 4 box2_x_read
mul box1_x_read:~0 box2_x_read:~0 part2_answer
@jmp &output_answers_and_halt

pair_finished_not_done:

# check for part1 threshold reached
add part1_limit -1 part1_limit
jt part1_limit &not_part1_time
rbo heap_size
@call &compute_part1_answer
rbo heap_size_inv
not_part1_time:

# adjust RB from &boxes[0] -> &boxes[box_table_size] == &pairs[0]
rbo box_table_size

# pair_count had better be greater than zero
@cpy __LINE__ assertion_failed_line
jf pair_count &assertion_failed

#############################################################################
@reference pop_pair_from_heap
@fn naked pop_pair_from_heap() global(pair_count)
add pair_count -1 pair_count
# if this leaves the heap empty, there's nothing to do 
mul pair_count 3 last_element
mul last_element -1 last_element_inv
rbo last_element:0
# save off the last element in the heap
@cpy ~0 le_0
@cpy ~1 le_1
@cpy ~2 le_2
# mark it as dead so we'll crash if we accidentally access it
@cpy 0 ~1
jf last_element_inv &end_siftDown
rbo last_element_inv:0
# Overwrite the root element of the heap with the (former) last element
@cpy le_0:0 ~0
@cpy le_1:0 ~1
@cpy le_2:0 ~2

@cpy 0 root

siftDown:

# in the docs:
#    iLeftChild(i) = 2i + 1
#    iRightChild(i) = 2i + 2
# we need to add 3 and 6 here cuz we're doing raw memory addresses and each element is 3 words
mul root 2 iLeftChild
add iLeftChild 3 iLeftChild
@jge iLeftChild:0 last_element &end_siftDown

add iLeftChild 0 child

add iLeftChild 3 iRightChild
@jge iRightChild:0 last_element &no_right_child
mul iLeftChild -1 iLeftChildInv
rbo iLeftChild
# I want a min-heap, so I need to check if the right child is greater than the right child
lt ~5 ~2 is_less
mul is_less 3 is_less
add is_less:0 child child
rbo iLeftChildInv:0
no_right_child:

add root:0 2 root_read
add child:0 2 child_read
# wikipedia article is checking a[root]<a[child]
# so we're checking for a[child]<a[root]
lt child_read:~0 root_read:~0 is_less
jf is_less &end_siftDown

# swap the two elements
mul root -1 root_inv
mul child -1 child_inv
rbo root
@cpy ~0 tmpa0
@cpy ~1 tmpa1
@cpy ~2 tmpa2
rbo root_inv:0
rbo child
@cpy ~0 tmpb0
@cpy ~1 tmpb1
@cpy ~2 tmpb2
@cpy tmpa0:0 ~0
@cpy tmpa1:0 ~1
@cpy tmpa2:0 ~2
rbo child_inv:0
rbo root
@cpy tmpb0:0 ~0
@cpy tmpb1:0 ~1
@cpy tmpb2:0 ~2
rbo root_inv

@cpy child root
@jmp &siftDown

end_siftDown:
@endfn
#############################################################################


@jmp &process_next_pair

#############################################################################
#
# output answers here

output_answers_and_halt:

@cpy &str_part1_answer_fmt ~1
@cpy part1_answer ~2
@call &printf

@cpy &str_part2_answer_fmt ~1
@cpy part2_answer ~2
@call &printf

hlt

### error paths for main body

too_few_boxes:
@cpy &str_too_few_boxes ~1
@jmp &print_error_and_die

#############################################################################
#
# compute_part1_answer
#
# PRECONDITIONS:
# - relative base is &boxes + heap_size

@fn 0 compute_part1_answer() global(boxes, heap_size, heap_size_inv, boxes_to_circuits, circuit_count, boxes_to_circuits_inv, part1_answer)

# undo local stack adjustment
rbo &auto__stack_size_inv
# rewind to &boxes[0]
rbo heap_size_inv
# forward to &circuits[0]
rbo boxes_to_circuits
mul circuit_count -2 circuits_inv
@cpy circuit_count circuits_left
@cpy 1 top1
@cpy 1 top2
@cpy 1 top3

examine_next_circuit:
# is it better than 3rd place?
@jle ~0 top3:0 &no_place

# okay, it's better than the current 3rd place
# is it better than 2nd place?

@jle ~0 top2:0 &place_top3

# okay, it's better than the current 2nd place
# is it beter than 1st place?

@jle ~0 top1:0 &place_top2

# yes!
@cpy top2 top3
@cpy top1 top2
@cpy ~0 top1
@jmp &no_place

place_top2:
@cpy top2 top3
@cpy ~0 top2
@jmp &no_place

place_top3:
@cpy ~0 top3

no_place:
rbo 2
add circuits_left -1 circuits_left
jt circuits_left:0 &examine_next_circuit

# part 1 answer is the product of the sizes of the 3 largest circuits
mul top1 top2 part1_answer
mul top3 part1_answer part1_answer

# rewind the stack
rbo circuits_inv:0 
rbo boxes_to_circuits_inv
rbo heap_size
rbo &auto__stack_size

@endfn

#############################################################################
#
# resolve_circuit_pointer(pointer_address)
#
# PRECONDITIONS:
# - relative base is &boxes + heap_size
# - 0 <= pointer_address < circuit_pointers_count
#
# Upon return:
# - ~1 contains the address of the circuit that is pointed to

@fn 1 resolve_circuit_pointer(pointer_address_arg) global(boxes, heap_size, heap_size_inv, boxes_to_circuit_pointers, boxes_to_circuits, boxes_to_circuits_inv, circuits_address)


@cpy pointer_address_arg pointer_address

rbo &auto__stack_size_inv
rbo heap_size_inv
add boxes_to_circuit_pointers pointer_address:0 circptr_read
@cpy circptr_read:~0 circuit_address
@cpy 0 any_merge

rbo boxes_to_circuits

follow_merge:
mul circuit_address -1 circuit_address_inv

rbo circuit_address:0
@jgt ~0 0 &final_circuit
@cpy 1 any_merge
@cpy ~1 circuit_address
rbo circuit_address_inv:0

@jmp &follow_merge
final_circuit:
rbo circuit_address_inv

rbo boxes_to_circuits_inv

jf any_merge:0 &no_merges
add boxes_to_circuit_pointers pointer_address circptr_write
@cpy circuit_address circptr_write:~0
no_merges:

rbo heap_size
rbo &auto__stack_size
@cpy circuit_address return0
@endfn



#############################################################################
#
# print_pairs()
#
@str str_pair_count_fmt: "Number of pairs: %d\n\n"
@str str_pair_fmt: "%d %d\n"

@reference print_pairs
@fn 0 print_pairs() local(pairs_left) global(printf, print_pairs, pair_count, boxes, box_table_size, str_pair_count_fmt, str_pair_fmt)

@cpy &str_pair_count_fmt ~1
@cpy pair_count ~2
@call &printf

add &boxes box_table_size pairs_ptr_1
add pairs_ptr_1 1 pairs_ptr_2
@cpy pair_count pairs_left
loop:
@cpy &str_pair_fmt ~1
@cpy pairs_ptr_1:*0 ~2
@cpy pairs_ptr_2:*0 ~3
@call &printf
add pairs_ptr_1 3 pairs_ptr_1
add pairs_ptr_2 3 pairs_ptr_2
add pairs_left -1 pairs_left
jt pairs_left &loop

@endfn




#############################################################################
#
# print_box_info()

@str str_box_count_fmt: "Number of boxes: %d\n\n"
@str str_box_fmt: "%d, %d, %d\n"

@fn 0 print_box_info() local(x, y, z) global(printf, str_box_fmt, str_box_count_fmt, box_count, boxes)  

@cpy &str_box_count_fmt ~1
@cpy box_count ~2
@call &printf
jf box_count &auto__return

@cpy box_count boxes_left
add &boxes 0 read_x
add &boxes 1 read_y
add &boxes 2 read_z
print_next_box:
@cpy read_x:*0 x
@cpy read_y:*0 y
@cpy read_z:*0 z
add read_x 4 read_x
add read_y 4 read_y
add read_z 4 read_z
@cpy &str_box_fmt ~1
@cpy x ~2
@cpy y ~3
@cpy z ~4
@call &printf
add boxes_left -1 boxes_left
jt boxes_left:0 &print_next_box

@endfn

###############################################################################

# @fn 0 memset(dest, ch, count)

# jf count &skip
# @cpy dest rdi
# loop:
# @cpy ch rdi:*0
# add rdi 1 rdi
# add count -1 count
# jt count &loop
# skip:

# @endfn

#############################################################################
#
# read_nonnegative_integer_checked(expected_terminator, empty_mode, newline_mode, eof_mode)
#
# Read a nonnegative integer from stdin, doing additional validation
#
# expected_terminator (~1): the character that is expected to terminate the number
# empty_mode          (~2): behavior if no characters are read
#       0 = zero-length input is invalid. even if the expected terminator is read, it counts as unexpected.
#       1 = zero-length input is valid, the returned value is zero
# newline_mode        (~2): behavior if terminated by '\n'
#       set to -1 if expected_terminator is '\n' and eof_mode is -1
#       0 = newline is invalid and will be treated as any other invalid character
#       1 = newline is valid if and only if it was the only character read
#      -1 = newline is a valid alternate to expected_terminator
# eof_mode            (~3): behavior if terminated by EOF
#      -1 = treat EOF as newline
#       0 = EOF is invalid and will generate an "unexpected EOF"
#       1 = EOF is valid if it was read immediately
#
# Return values:
#       ~1 = the value that was read (or 0 if no digits were read, but the read was still considered successful)
#       ~2 = 1 if a value was successfully read
#            0 if a blank input was successfully read
#           -1 if a value was successfully read and terminated by a newline instead of expected_terminator
#           -2 if a value was successfully read and terminated by an EOF instead of expected_terminator
#
# This is really complicated, so I'm making a tool to help me test it.
#
# | expected_terminator | empty_mode | newline_mode | eof_mode | input            | outcome
# |---------------------|------------|--------------|----------|------------------|---------------------------

@fn 2 read_nonnegative_integer_checked(expected_terminator, empty_mode, newline_mode, eof_mode) local(status) global(read_nonnegative_integer, report_unexpected_character, report_unexpected_eof)

@call &read_nonnegative_integer
# set status to 1 if we read a value, else 0
lt 0 ~2 status
@jeq ~3 expected_terminator &got_expected_terminator
@jeq ~3 '\n' &got_newline
jf ~3 &got_eof
# we didn't get the expected terminator, a newline, *or* EOF. bail.
@jmp &report_unexpected_character

got_expected_terminator:
# if empty_mode is 1, we always accept the expected terminator
jt empty_mode &exit_fn
# if empty_mode is 0, we accept only if we read a value
jt status &exit_fn
@jmp &report_unexpected_character

got_eof:
# if eof_mode is 0, eof is unexpected
jf eof_mode &report_unexpected_eof
# if eof_mode is -1, eof is treated like a newline
@jlt eof_mode 0 &got_newline
# if eof_mode is 1, eof is valid only if we didn't read any digits
jf status &exit_fn
@jmp &report_unexpected_eof

got_newline:
# if newline_mode is 0, treat it as an invalid character
jf newline_mode &report_unexpected_character
jf status &no_adjust_status
eq ~3 0 actually_eof
add status actually_eof:0 status
mul status -1 status
no_adjust_status:
# if newline_mode is -1, it acts like expected_terminator
@jlt newline_mode 0 &got_expected_terminator
# otherwise, newline_mode is 1, and it's only valid when we didn't read any digits
jf status &exit_fn
@jmp &report_unexpected_character

exit_fn:
@cpy ~1 return0
@cpy status return1

@endfn

report_unexpected_character:
# having this jump makes eof_mode easier to implement
jf ~3 &report_unexpected_eof

@cpy &str_unexpected_character_in_input_fmt ~1
@cpy ~3 ~2
add input_line 1 ~3
add input_column 1 ~4
@jmp &printf_error_and_die

report_unexpected_eof:
@cpy &str_unexpected_end_of_file_fmt ~1
add input_line 1 ~2
add input_column 1 ~3
@jmp &printf_error_and_die

############################################################################################
# input.lib
# version 20251205-0001

# 0-based line and column number for stdin
@raw pending_newline: 0 input_line: 0 input_column: 0

#############################################################################
#
# Read a nonnegative integer from input.
#
# Return values:
#    ~1 - the value that was read, -or- 0 if no digits were read
#    ~2 - the number of digits that were read
#    ~3 - the (non-digit) input value that terminated the read, or 0 if the input was terminated by an EOF indicator

@fn 3 read_nonnegative_integer() local(acc, digit_count, ch) global(pending_newline, input_line, input_column)

@cpy 0 acc
@cpy 0 digit_count

# if the last read terminated in '\n', increment the line number and reset the column
jf pending_newline &read_loop
@cpy 0 pending_newline
add input_line 1 input_line
@cpy 0 input_column

read_loop:
in ch
@jeq ch '\r' &read_loop
@jle ch 4 &handle_eof
@jeq ch 26 &handle_eof
add input_column 1 input_column
@jlt ch '0' &terminate
@jgt ch '9' &terminate
add digit_count 1 digit_count
add ch -'0' ch
mul acc 10 acc
add acc ch acc
@jmp &read_loop

handle_eof:
@cpy 0 ch

terminate:
# if we stopped because of a newline, set things up so we'll increment the line number and reset the column number on the next read
# not only is doing it that way slightly easier, it means that error messages caused by an unexpected newline won't be reported
# against the wrong line
eq ch '\n' pending_newline

# with no parameters:
# 	acc and return0 are aliased
#   digit_count and return1 are aliased
#   ch and return2 are aliased
#
# also, in retrospect, topaz should've made them return1, return2, return3 -- that way their names would match the ~1 ~2 ~3 you use
# in the code.

@reference return0 return1 return2

@endfn


############################################################################################
# output.lib
# version 20251205-0001

############################################################################################
#
#  output_integer(value)
#
# in ASCII mode, prints value in ASCII
# in raw mode, outputs value directly
# if raw mode is enabled and use_dle is on, raw values are prefixed with 0x10 (DLE)

@fn 0 output_integer(value) global(print_decimal, raw_output, use_dle)

jt raw_output &do_raw_output
# this works ONLY when both routines have the same number of locals+parameters
# UPDATE: tail-call doesn't actually work correctly because the relative base register (i.e. stack pointer) isn't adjusted correctly.
@cpy value ~1
@cpy &no_raw_output ~0
@jmp &print_decimal

do_raw_output:

jf use_dle &no_dle
out 16
no_dle:
out value

no_raw_output:

@endfn

# print possibly-negative decimal number
print_decimal:
lt ~1 0 _print_decimal_is_negative
jf _print_decimal_is_negative:0 &print_nonnegative_decimal
out '-'
mul ~1 -1 ~1
# fall through to print_nonnegative_decimal

# print nonnegative decimal number (negative numbers will not be printed)
# changing this to support negatives would be easy but I don't need it
@fn 0 print_nonnegative_decimal(n) global(print_next_decimal_digit)
jf n &print_zero
@cpy n ~1
@cpy 1 ~2
@call &print_next_decimal_digit
@jmp &exitfun
print_zero: out '0'
exitfun:
@endfn

@fn 1 print_next_decimal_digit(n, mask) local(dig, negmask)

# PRECONDITIONS: n >= mask, mask is a power of 10
# POSTCONDITIONS: upon return, ~1 has all powers of 10 greater than mask removed

@cpy n ~1
@jlt n mask &exitfn

mul mask 10 ~2
@call &print_next_decimal_digit
@cpy ~1 n

mul mask -1 negmask
@cpy '0' dig
compute_digit:
@jlt n mask &done_compute_digit
add dig 1 dig
add n negmask n
@jmp &compute_digit
done_compute_digit:

out dig

exitfn:
@cpy n return0
@endfn


# GOTCHA: return parameters and incoming arguments share stack space, so be careful

#########################################################
#
# print_string(&str)

@fn 0 print_string(string_address) local(strlen, tmpchar)

@cpy string_address read_strlen
add read_strlen:*0 0 strlen
add 1 string_address string_reader
message_print_loop:
add string_reader:*0 0 tmpchar
add string_reader 1 string_reader
out tmpchar
add strlen -1 strlen
jt strlen &message_print_loop

@endfn

#########################################################
#
# printf(&str, ...)
#
# TODO: experiment with using NUL-terminated strings instead.

@fn 0 printf(format_string, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) global(output_integer)

@reference arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9
@cpy 0 arg_shift
@cpy format_string read_length_ptr
@cpy read_length_ptr:*0 format_string_length
jf format_string_length:0 &exit_fn
add format_string 1 read_string_ptr

process_next_char:
@cpy read_string_ptr:*0 next_char
add read_string_ptr 1 read_string_ptr
add format_string_length -1 format_string_length
@jeq next_char '%' &process_format
out next_char:0
@jmp &advance_loop
process_format:
@cpy read_string_ptr read_string_ptr2
@cpy read_string_ptr2:*0 next_char
add read_string_ptr 1 read_string_ptr
add format_string_length -1 format_string_length
@jeq next_char '%' &format_literal_percent
@jeq next_char 'c' &format_char
@jeq next_char 'C' &format_printable_char
# assume %d by default

format_integer:
@cpy arg0 ~1
@call &output_integer
rbo 1
add arg_shift -1 arg_shift
@jmp &advance_loop

format_literal_percent:
out '%'
@jmp &advance_loop

format_printable_char:
@jge arg0 32 &format_char
out '\\'
@jeq arg0 '\n' &escape_n
@jeq arg0 '\r' &escape_r
@jeq arg0 0 &escape_0
@jeq arg0 '\t' &escape_t
out '\\'
out 'd'
@jmp &format_integer
escape_n:
@cpy 'n' arg0
@jmp &format_char
escape_r:
@cpy 'r' arg0
@jmp &format_char
escape_0:
@cpy '0' arg0
@jmp &format_char
escape_t:
@cpy 't' arg0
@jmp &format_char

format_char:
out arg0
rbo 1
add arg_shift -1 arg_shift
@jmp &advance_loop

advance_loop:
jt format_string_length &process_next_char

exit_fn:
rbo arg_shift:0
@endfn




#####################################
#
# error routines. call with @jmp, not @call (well, @call is fine, but it's a waste)

####################################
#
# assertion_failed()
#
# Print out "Error: Assertion failed on line <line number>" and halt.

assertion_failed:
@cpy &str_assertion_failed_fmt ~1
@cpy assertion_failed_line:0 ~2
@jmp &printf_error_and_die

#####################################
#
# print_error_and_die(&str_message)
#
# Outputs "Error: " followed by the supplied message, then halts.
#

print_error_and_die:
rbo 2
@cpy &str_error ~1
@call &print_string
rbo -2
# fall through to print_and_die
@reference print_and_die

#####################################
#
# print_and_die(&str_message)
#
# Outputs the supplied message, then halts.

print_and_die:
@call &print_string
hlt

#####################################
#
# printf_error_and_die(&str_format, ...)
#
# Outputs "Error: " followed by the formatted message, then halts.

printf_error_and_die:
# move the stack pointer far, far away so we don't trash the incoming parameters
rbo 100
@cpy &str_error ~1
@call &print_string
rbo -100
# fall through to print_and_die
@reference printf_and_die

#####################################
#
# printf_and_die(&str_format, ...)
#
# Outputs the formatted message, then halts.

printf_and_die:
@call &printf
hlt

###################################################################################
# Strings

@str str_error: "Error: "
@str str_too_few_boxes: "Too few boxes (need at least 2)\n"
@str str_unexpected_character_in_input_fmt: "Unexpected character '%C' in input at line %d, column %d\n"
@str str_unexpected_end_of_file_fmt: "Unexpected end-of-file in input at line %d, column %d\n"
@str str_assertion_failed_fmt: "Assertion failed on line %d\n"
@str str_part1_answer_fmt: "Part 1: %d\n"
@str str_part2_answer_fmt: "Part 2: %d\n"

###################################################################################

@raw part1_answer:0 part2_answer:0

@raw stat_pairs_processed: 0
@raw stat_pairs_redundant: 0
@raw stat_pairs_adjoin: 0
@raw stat_circuits_merged: 0
@raw stat_pairs_new: 0

# number of disjoint circuits MINUS ONE
# this ensures that when part 2 is ready, disjoint_circuit_count is 0.
@raw disjoint_circuit_count: -1

@raw box1: 0 box2: 0
@raw box_x: 0 box_y: 0 box_z: 0
@raw box_count: 0
@raw box_table_size: 0
@raw box_table_size_inv: 0
@raw pair_table_address: 0
@raw pair_count: 0
@raw pair_table_size: 0
@raw pair_table_size_inv: 0
@raw boxes_to_circuit_pointers: 0
@raw boxes_to_circuit_pointers_inv: 0
@raw boxes_to_circuits: 0
@raw boxes_to_circuits_inv: 0
@raw circuit_pointers_address: 0
@raw circuit_pointers_count: 0
@raw circuit_pointers_count_inv: 0
# number of boxes that are have not been connected to any other
@raw unconnected_box_count: 0
# number of disjoint circuits
@raw circuits_address: 0
@raw circuit_count: 0
@raw heap_size_inv: 0

boxes:
# boxes:
# sizeof(box)=4   x, y, z, circuit_ptr_address
#
# pairs:
# sizeof(pair)=3  box1, box2, distance
#
# circuit_pointers:
# sizeof(ptr)=1   address of circuit node

# circuits:
#
# sizeof(circuit)=2   num_boxes, merged_to
