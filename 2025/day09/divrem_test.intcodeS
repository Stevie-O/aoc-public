rbo &auto__end
in ~1
in ~2
@call &divrem_positive
#out 16
out ~1
#out 16
out ~2
hlt

###############################################################################
#
# divrem_positive(a, b)
#
# PRECONDITION: b > 1
#
# (b=1 is also valid, but that will just spend a lot of unnecessary time to return (a, 0))
#
# Originally, 
#
# In theory, should require approximately 17 instructions times ceil(log2(a) - log2(b)).
# In practice, seems to take much more? I need to study it more.
#
# Upon return:
#       ~1 is q
#		~2 is r
#
# where
#	q is the smallest nonnegative integer such that a = qb + r
#
# if a >= 0, this means ~1 is floor(a / b) and ~2 is (a % b)
# if a < 0, q=0 and r=a
#
# Version 2
#   This version directly manipulates the relative base instead of making recursive calls.

@fn 2 divrem_positive(a, b)

@cpy a r
@cpy 0 q
@jgt a b &nontrivial
# if we're here: a <= b
eq a b q
eq q 0 r
# a  < b:  q=0, r=1
# a == b:  q=1, r=0
mul a r r
@jmp &exit

nontrivial:
# a > b
# push b onto the stack
@cpy b ~0
@cpy 1 push_count
# push 2b, 4b, 8b, ... onto the stack until it's greater 
double_b:
mul ~0 2 ~1
rbo 1
add push_count 1 push_count
@jlt ~0 r &double_b

# okay, ~0 is (2^n)b for the smallest nonnegative integer n such that (2^n)b >= a
# push_count is the one more than the number of times we did 'rbo 1', which is always at least 2 here

pop_loop:
mul q 2 q
@jlt r ~0 &bit_clear
mul ~0 -1 ~0
add r ~0 r
add q 1 q
bit_clear:
rbo -1
add push_count -1 push_count
jt push_count:0 &pop_loop

# the above loop executes "rbo -1" exactly one time too many
# and I can't figure out an elegant way to avoid that
rbo 1

exit:
@cpy q:0 return0
@cpy r:0 return1

@endfn
